#import "template.typ": *
#show: template.with(
  title: [考研 408 复习笔记],
  short_title: "408 笔记",
  description: [
    408 里不太会的地方
  ],
  date: datetime(year: 2024, month: 10, day: 24),
  authors: (
    (
      name: "GitHub @ Origami404",
      link: "",
      affiliations: "",
    ),
  ),
  affiliations: (),
  lof: false,
  lot: false,
  lol: false,
  // bibliography_file: "refs.bib",
  paper_size: "a4",
  cols: 1,
  text_font: "Noto Serif CJK SC",
  code_font: "CaskaydiaCove NFM",
  accent: blue, // blue
)

#show heading: it => { it; v(0.3em) }
#set list(marker: ([★], [⤥], [›]))

#let pic-side-by-side(width: 100%, img-left-path, img-right-path) = {
  grid(
    align: center + horizon, columns: 2,
    image(width: width, img-left-path), image(width: width, img-right-path)
  )
}

= 算法

== 堆

- 每个结点的值都大于/小于父结点的二叉树
- 主要操作是向上和向下调整
  - 插入的时候按照层次顺序插入, 并依次向上调整
  - 删除的时候把堆顶元素和最后一个元素交换, 然后删除最后一个元素, 然后向下调整
- 可以通过对数组逆序逐个向下调整来 $O(N)$ 建堆

== 树与图

- 树的深度和高度都默认按根节点为 $1$ 算
- 二叉树
  - 默认是不左右对称的, 也就是说左右儿子交换之后不是同一棵二叉树
- 各类性质
  - 满: $2^h - 1$ 个
  - 完全: 按层次顺序拥有满二叉树的前若干个结点
  - 平衡: 左右子树高度差不超过 $1$
  - 正则: 每个非叶子结点都有两个儿子
- AOE vs AOV
  - AOV 网: 结点表示活动, 如 $i -> j$ 表示活动 $i$ 要先于活动 $j$ 进行
  - AOE 网: 边表示互动, 边权代表活动耗时

== 树/森林 $<->$ 二叉树

#pic-side-by-side(width: 55%, "assets/哈夫曼/树.png", "assets/哈夫曼/树的二叉树.png")
#pic-side-by-side(width: 55%, "assets/哈夫曼/森林.png", "assets/哈夫曼/森林的二叉树.png")

二叉树里有左儿子的那就是要下一层; 二叉树里有右儿子的那就是森林里一颗新的树.

== B 树

- $m$ 阶 B 树每个节点有 $ceil(m / 2)$ 到 $m$ 个子树, 然后有对应数量减一的键, 子树分布在键之间, 包含两个键之间的值
- 主要操作是分裂与合并
  - 对于太满的结点, 砍成两半, 中心的放到父节点去, 然后递归向上进行
  - 对于不够多的结点
    - 如果是非叶子结点, 可以先薅子树的, 然后递归向下进行
    - 如果没有子树, 则尝试薅兄弟结点的; 还是没有才尝试进行合并
- B+ 树让叶子层节点含了全部键, 然后每个非叶节点包含了键那么多的子树, 子树的最后一个键就是父结点对应的键

== 排序

- 插入排序 (稳定)
  - 维护有序前缀数组, 每次从无序部分找一个元素, 再找到它在有序部分的位置, 再挪动插入
  - 直接插入排序: 每次 $O(N)$ 在有序部分找位置
  - 二分插入排序: 每次 $O(log N)$ 在有序部分二分地找位置
- 希尔排序
  - 把原数组分成 $k$ 段做直接插入排序, 然后再总地来一遍直接插入排序
- 交换排序
  - 每次一个个元素交换, 不涉及一整段的搬运
  - 冒泡 (稳定): 每次 $O(N)$ 地把元素向前冒
  - 快排
- 选择排序
  - 选出整个序列中的第 $k$ 小, 然后直接放到 $a[k]$
  - 简单选择排序: 扫 $N$ 次序列找每次的最小依次放到对应位置
  - 堆排序: 先 $O(N)$ 建堆, 再逐个弹出
- 归并排序 (稳定)
- 基数排序 (稳定)
- 计数排序: 对每个值统计数组中比它小的其他值的个数 $k$, 然后直接放进 $a[k]$

注意快排和归并排序的栈用量也要算进空间复杂度里.

#pagebreak()

= 计组

== 浮点数的表示

- $N = (-1)^s * 1.m * 2^(e - 127 "or" 1023)$
- `float` 是 `s1e8m23`, `double` 是 `s1e11m52`
- 特殊值
  - $m = 0$: 数学上合理的特殊值
    - $e = 00...0$: 正负零
    - $e = 11...1$: 正负无穷大
  - $m != 0$:
    - $e = 00...0$: 非规格化数
      - 此时值为 $0.m * 2^(-126)$, 和普通浮点数的转换规则不同
    - $e = 11...1$: NaN
- 浮点数运算要: 对阶, 算 $m$, 规格化, 舍入
  - 一般都是保留中间对阶的小数部分, 最后再舍入

== 异常与中断

- 异常: 来自 CPU 内, 在指令启动后完成前发生
  - 程序性异常
    - 故障 fault: 非法 opcode, 缺页, 除 0
    - 自陷 trap: 预先通过指令设定的异常, 如断点
  - 硬故障 / 终止: 内部错误, 随机发生
- 中断: 来自外部设备, 每次指令完成后 CPU 检查 INTR
  - 可屏蔽中断: DMA, I/O, 定时器 
    - (屏蔽后直接被 INTR 丢弃, CPU 看不到)
  - 不可屏蔽中断: 外部硬件故障
- 中断处理
  - 硬件部分: 关中断, 存 PC, 识别中断号转到处理程序
  - 软件部分: 保存寄存器现场, 换中断向量, 开中断, 处理

== 总线

- 分时和共享的线路
- 分类
  - 外部总线 (IO 总线): USB, PCIE
  - 系统总线
    - 数据总线, 地址总线, 控制总线
- 计算机总线架构
  - 双总线结构
    - CPU 通过系统总线连接内存和 IO 控制器, IO 控制器通过 IO 总线连接外设
  - 三总线结构
    - CPU 通过系统和 IO 总线分别连接内存和外设; 外设通过 DMA 总线连接内存 
- 带宽计算
  - 总线重要指标: 工作周期/工作频率, 一般和系统时钟差一个倍率
  - 带宽 = 工作频率 \* 每次传输数据量
- DMA
  - 外部设备要输入时, 先通知 DMA 控制器. DMA 控制器中断通知 CPU 让出总线
  - 随后 DMA 控制器主持 DMA, 与 CPU 其他运算并行进行, 直接数据送进内存
  - DMA 占用总线过程中, CPU 不能再访问内存. *DMA 优先级比 CPU 高*
    - 可以使用*周期挪用*方式, 将 DMA 传输的数据拆成小片多次传输, 中间交织着让 CPU 可以访存
    - 也可以使用*交替访存*方式, 规定每个周期内的时间一半给 CPU, 一半给 DMA, 这样 DMA 就不再需要通知 CPU 抢占总线控制权了

== 存储系统

- DRAM 
  - 指定地址: 先给一个行, 再给一个列, 所以*地址寄存器位宽只是 $max("行宽", "列宽")$*
  - 突发传输: 收到一个首地址之后, 把一整行的内容都放到芯片内部的缓冲区里, 然后接下来每个周期再对外拿出一个

#pagebreak()

= OS

- SLOOPing
  - 把要传给低速 IO 设备的数据先写到硬盘上, 让单独的进程慢慢地把硬盘上的数据往 IO 设备上丢.
  - 这样不仅可以减少内核消耗在等待 IO 上的时间, 还可以让低速设备在不同进程之间共享

== 机械硬盘

- 地址组成
  - 柱面号: *要注意盘是单面的还是双面的*
  - 磁道号 / 盘面号: 第几个磁道 $r$
  - 扇区号: 第几个扇区 $theta$
- 存取时间
  - 寻道时间: $T_s = m times n + s$
    - $m$ 是磁头移动一条磁道长度的时间, $n$ 是待移动的磁道数量, $s$ 是启动磁头臂所需时间
  - 旋转延迟时间: $T_r = 1 / (2 r)$
    - $r$ 是旋转速度. 注意理论上只需要盘面转半圈就可以到目标位置了, 所以要除以二
  - 传输时间: $T_t = (b / N) * (1 / r)$
    - $b / N$ 是指每次读写的字节长度 $b$ 占整个磁道字节长度 $N$ 的比例, 这个比例乘以转一圈的时间即可
  - 总平均存取时间: $T_a = T_s + T_r + T_t$
- 调度算法
  - FCFS: 先来先服务
  - SSTF: 最短寻道时间优先
  - SCAN
    - 只有磁头移动到最外侧才能向内, 移动到最内侧才能向外
    - 基本上是电梯的调度算法
  - C-SCAN
    - 只有在从内往外移动时才响应读写请求, 从外回到内时直接快速回去
  - LOOK
    - 类似 SCAN, 但每次只移动到最外/最内的请求处, 而不是傻傻地到磁盘的最外/最内处
  - C-LOOK: LOOK + C-SCAN
- 交替编号
  - 磁头读入了一个扇区之后需要一小段处理时间, 如果扇区是连续排列的, 那么下一个扇区就会在磁头发呆的这一小段时间里飘过去, 不利于连续读写
  - 让扇区间隔排列, 比如 `1 5 2 6 3 7 4 8`, 就可以连续地读连续的扇区了

== 文件系统

- FAT
  - 有一个全磁盘唯一的 FAT 表, 表中每个 int 对应一个簇, 指示这个簇的下一个簇应该是什么
  - 目录项 = 文件名 + 文件元信息 + 首个簇
- Ext
  - 每个文件有一个 INode, 存放文件的元信息和文件对应的簇
    - 采用混合索引分配方式
  - 目录项 = 文件名 + INode 号

#pagebreak()

= 计网

== 物理层
- 编码: 信息 -> 数字信号
  - 曼彻斯特编码: 每个周期中间信息下降是 1, 信号上升是 0
  - *差分*曼彻斯特编码: *跨周期*时信号不变是 1, 信号改变是 0
- 数字调制: 信息 -> 模拟信号
  -  QAM: 同时利用相位和幅度调制区分, 相位数量 $times$ 幅度数量就是码元数量 $k$, 称为 $k$-QAM
- 信道速率计算
  - 理想低通信道: $c = 2 W "Buad" = 2 W log_2 V$, $W$ 是频率带宽, $V$ 是码元数量
  - 噪声信道: $c = W log_2 (1 + S / N)$, $W$ 是频率带宽, $S$ 是信号功率, $N$ 是噪声功率
  - 信噪比: $"dB" = 10 log_10 (S / N)$

== 链路层

- 特点: 封装成帧, 透明传输, 差错检测, 流量控制, 介质控制
- CRC 计算
  - $G(x) = sum_(i = 0) b_i x_i$ 对应的二进制串就是 $[b_(n - 1) b_(n - 2) ... b_0]$
  - 发送时
    - 在原始数据后边垫 $n$ 个 $0$ ($G(x)$ 串长度这么多个)
    - 计算模二除法 (此时减法等同于异或): 垫零原始数据 $div$ 串 得到余数
    - 原始数据后跟余数就是发送数据
  - 接收时
    - 接受到的数据 模二除 串, 余数必须为 $0$, 否则数据有误
- 流量控制: 滑动窗口
  - SW 协议: 发一个等一个确认
  - GBN 协议: $W_T <= 2^n - 1$, 一口气发 $W_T$ 个, 然后开始等确认, 确认一个就往后再发一个. 有一个确认收不到就重传所有正在等确认的.
  - SR 协议: $W_T <= 2^(n - 1)$, GBN, 但是接收方可以用 NACK 包指定要重传哪个
- 介质控制
  - 多设备复用: 码分复用: CDMA
    - 每个设备有一个向量. 链路上的数据序列和设备向量内积之后, 结果是正的就是这个设备在发 $1$, 负的就是在发 $0$, 零就是这个设备没有在发
  - 半双工线路防止争用: CSMA/CD
    - 先听后发, 边听边发, 冲突即停, 随机重发
    - 等待时间: $r = "rand"[0, 2^(min("重传次数", 10)) colored(- 1)]$, 等 $r$ 这么多倍争用期时间
- VLAN
  - 802.1Q MAC 协议, 往 MAC 头插入了一个 4 字节的 VLAN 标签

=== 无线网络

- IEEE 802.11
  - 有线网络的 MAC 协议叫 IEEE 802.3
- 有固定基础设施
  - CSMA/CA: 冲突也不停发; 发之前先等一小段时间 (IFS); 提前通告信道占用时间; 
  - 组织结构
    - 一个 AP 和它服务的所有终端构成一个 BSS (基本服务集)
    - AP 之间可以借助 DS (分配系统) 链接起来, 若干个 BSS 组成一个 ESS (扩展服务集), 对终端而言视为一个 BSS
    - 一个 DS 里有一个 Portal, 是整个 ESS 到有线网络的出口
  - 802.11 MAC
    - 重要域: 帧控制部分; 三个地址: 接收地址, 发送地址, 源/目的地址
    - 从 AP 发到终端
      - 地址 1 = 接收地址 (终端), 地址 2 = 发送地址 (AP), 地址 3 = 源地址 (包从有线网的哪里来)
    - 从终端发到 AP
      - 地址 1 = 接收地址 (AP), 地址 2 = 发送地址 (终端), 地址 3 = 目的地址 (包要去有线网的哪里)
- 无固定设施 / 自组网络 (ad hoc network)

== 网络层

- IP
  - 分片
    - 将 IP 包按照链路层最大长度 MTU 切成若干份
    - MF = 1: 后面还有分片, DF = 1: 不允许分片
    - 片偏移单位是 8B, 分片长度必定是 8B 的整数倍
- ARP
  - ARP 请求分组: 目的地址为全 F
  - ARP 响应分组: 目的地址就是发送请求的地址
  - 请求局域网以外的 IP 地址时, NAT 路由器负责响应自己的 MAC 回去
- DHCP
  - 发现报文
    - 需要 IP 地址的主机启动时广播发出
    - 源地址全 0, 目的地址全 1
  - 提供报文
    - DHCP 服务器对发现报文的响应, 数据中包含了提供给主机的 IP 地址
    - 源地址为 DHCP 服务器地址, 目的地址全 1
  - 请求报文
    - 主机对服务器的提供报文的响应, 表示接受提供的 IP 地址
    - 源地址为全 0, 目的地址全 1
  - 确认报文
    - 服务器对请求报文的确认
    - 源地址为服务器地址, 目的地址全 1

== 传输层

- 头部长度 (Byte)
  - TCP: $20 + 4N$, UDP: $8$
- TCP 基础
  - TCP 的序号是数据的字节序号 (不算头长), 不是 MSS 序号
  - 三次握手: SYN, SYN+ACK, ACK
  - 四次挥手: FIN, ACK, FIN+ACK, ACK, 然后等 2MSL 之后才关闭
  - 带 SYN 和 FIN 的包不准携带数据, 消耗一个序号; 带 ACK 的包可选地携带数据, 根据携带的数据大小消耗序号, 不携带则不消耗
  - 两端各自会维护一个序号. 三次握手时只有第一个 SYN 是发送方发的, 所以发送方的序号只会从 $x + 1$ 开始; 同理 SYN+ACK 是接收方发的, 所以不会导致发送方的序号再加一次. FIN 同理 
- TCP 拥塞控制
  - cwnd 指同时发送多少个 MSS
  - 慢开始: cwnd = 1, 然后 1, 2, 4, 8, ..., 直到 ssthresh; 此后每次成功完整传送之后 cwnd += 1; 
  - 拥塞避免: 一旦拥塞, ssthresh = cwnd / 2, 然后
      - 慢恢复 (超时时用): cwnd = 1, 重复慢开始
      - 快恢复 (三冗余 ACK 时用): cwnd = ssthresh

#pic-side-by-side(width: 100%, "assets/三次握手.png", "assets/四次挥手.png")

== 应用层

- FTP
  - 在 21 端口建立控制链接
  - 在 20 端口建立数据链接
- 电子邮件
  - SMTP: 发送邮件, 推
    - SMTP 只能传 ASCII, 其他格式要通过 MIME 转换过去传
  - POP3: 接受邮件, 拉
- HTTP
  - HTTP 是无连接的: 每次 HTTP 请求开始都要有一个 RTT 的建立 TCP 链接的过程
  - 持续链接是指一个页面中传元素 (图片...) 可以复用请求页面时建立的 HTTP 链接