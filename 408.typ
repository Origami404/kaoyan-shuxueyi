#import "template.typ": *
#show: template.with(
  title: [考研 408 复习笔记],
  short_title: "数一笔记",
  description: [
    408 里不太会的地方
  ],
  date: datetime(year: 2024, month: 10, day: 24),
  authors: (
    (
      name: "GitHub @ Origami404",
      link: "",
      affiliations: "",
    ),
  ),
  affiliations: (),
  lof: false,
  lot: false,
  lol: false,
  // bibliography_file: "refs.bib",
  paper_size: "a4",
  cols: 1,
  text_font: "Noto Serif CJK SC",
  code_font: "CaskaydiaCove NFM",
  accent: blue, // blue
)

#show heading: it => { it; v(0.3em) }
#set list(marker: ([★], [⤥], [›]))

= 算法

== 堆

- 每个结点的值都大于/小于父结点的二叉树
- 主要操作是向上和向下调整
- 可以通过对数组逆序逐个向下调整来 $O(N)$ 建堆

== 树与图

- 树的深度和高度都默认按根节点为 $1$ 算
- 二叉树
  - 默认是不左右对称的, 也就是说左右儿子交换之后不是同一棵二叉树
- 各类性质
  - 满: $2^h - 1$ 个
  - 完全: 按层次顺序拥有满二叉树的前若干个结点
  - 平衡: 左右子树高度差不超过 $1$
  - 正则: 每个非叶子结点都有两个儿子
- AOE vs AOV
  - AOV 网: 结点表示活动, 如 $i -> j$ 表示活动 $i$ 要先于活动 $j$ 进行
  - AOE 网: 边表示互动, 边权代表活动耗时

== B 树

- $m$ 阶 B 树每个节点有 $ceil(m / 2)$ 到 $m$ 个子树, 然后有对应数量减一的键, 子树分布在键之间, 包含两个键之间的值
- 主要操作是分裂与合并
  - 对于太满的结点, 砍成两半, 中心的放到父节点去, 然后递归向上进行
  - 对于不够多的结点
    - 如果是非叶子结点, 可以先薅子树的, 然后递归向下进行
    - 如果没有子树, 则尝试薅兄弟结点的; 还是没有才尝试进行合并
- B+ 树让叶子层节点含了全部键, 然后每个非叶节点包含了键那么多的子树, 子树的最后一个键就是父结点对应的键

== 排序

- 插入排序 (稳定)
  - 维护有序前缀数组, 每次从无序部分找一个元素, 再找到它在有序部分的位置, 再挪动插入
  - 直接插入排序: 每次 $O(N)$ 在有序部分找位置
  - 二分插入排序: 每次 $O(log N)$ 在有序部分二分地找位置
- 希尔排序 不稳定 
  - 把原数组分成 $k$ 段做直接插入排序, 然后再总地来一遍直接插入排序
- 交换排序
  - 每次一个个元素交换, 不涉及一整段的搬运
  - 冒泡 (稳定): 每次 $O(N)$ 地把元素向前冒
  - 快排
- 选择排序
  - 选出整个序列中的第 $k$ 小, 然后直接放到 $a[k]$
  - 简单选择排序: 扫 $N$ 次序列找每次的最小依次放到对应位置
  - 堆排序: 先 $O(N)$ 建堆, 再逐个弹出
- 归并排序 (稳定)
- 基数排序 (稳定)
- 计数排序: 对每个值统计数组中比它小的其他值的个数 $k$, 然后直接放进 $a[k]$

= 计组

== 浮点数的表示

- $N = (-1)^s * 1.m * 2^(e - 127 "or" 1023)$
- `float` 是 `s1e8m23`, `double` 是 `s1e11m52`
- 特殊值
  - $m = 0$: 数学上合理的特殊值
    - $e = 00...0$: 正负零
    - $e = 11...1$: 正负无穷大
  - $m != 0$:
    - $e = 00...0$: 非规格化数
      - 此时值为 $0.m * 2^(-126)$, 和普通浮点数的转换规则不同
    - $e = 11...1$: NaN
- 浮点数运算要: 对阶, 算 $m$, 规格化, 舍入
  - 一般都是保留中间对阶的小数部分, 最后再舍入

== 异常与中断

- 异常: 来自 CPU 内, 在指令启动后完成前发生
  - 程序性异常
    - 故障 fault: 非法 opcode, 缺页, 除 0
    - 自陷 trap: 预先通过指令设定的异常, 如断点
  - 硬故障 / 终止: 内部错误, 随机发生
- 中断: 来自外部设备, 每次指令完成后 CPU 检查 INTR
  - 可屏蔽中断: DMA, I/O, 定时器 
    - (屏蔽后直接被 INTR 丢弃, CPU 看不到)
  - 不可屏蔽中断: 外部硬件故障
- 中断处理
  - 硬件部分: 关中断, 存 PC, 识别中断号转到处理程序
  - 软件部分: 保存寄存器现场, 换中断向量, 开中断, 处理

== 总线

- 分时和共享的线路
- 分类
  - 外部总线 (IO 总线): USB, PCIE
  - 系统总线
    - 数据总线, 地址总线, 控制总线
- 计算机总线架构
  - 双总线结构
    - CPU 通过系统总线连接内存和 IO 控制器, IO 控制器通过 IO 总线连接外设
  - 三总线结构
    - CPU 通过系统和 IO 总线分别连接内存和外设; 外设通过 DMA 总线连接内存 
- 带宽计算
  - 总线重要指标: 工作周期/工作频率, 一般和系统时钟差一个倍率
  - 带宽 = 工作频率 \* 每次传输数据量
- DMA
  - 外部设备要输入时, 先通知 DMA 控制器. DMA 控制器中断通知 CPU 让出总线
  - 随后 DMA 控制器主持 DMA, 与 CPU 其他运算并行进行, 直接数据送进内存

= OS

= 计网

== 物理层
- 编码: 信息 -> 数字信号
  - 曼彻斯特编码: 每个周期中间信息下降是 1, 信号上升是 0
  - 差分曼彻斯特编码: 跨周期时信号不变是 1, 信号改变是 0
- 数字调制: 信息 -> 模拟信号
  -  QAM: 同时利用相位和幅度调制区分, 相位数量 $times$ 幅度数量就是码元数量 $k$, 称为 $k$-QAM
- 信道速率计算
  - 理想低通信道: $c = 2 W "Buad" = 2 W log_2 V$, $W$ 是频率带宽, $V$ 是码元数量
  - 噪声信道: $c = W log_2 (1 + S / N)$, $W$ 是频率带宽, $S$ 是信号功率, $N$ 是噪声功率
  - 信噪比: $"dB" = 10 log_10 (S / N)$

== 链路层

- 特点: 封装成帧, 透明传输, 差错检测, 流量控制, 介质控制
- CRC 计算
  - $G(x) = sum_(i = 0) b_i x_i$ 对应的二进制串就是 $[b_(n - 1) b_(n - 2) ... b_0]$
  - 发送时
    - 在原始数据后边垫 $n$ 个 $0$ ($G(x)$ 串长度这么多个)
    - 计算模二除法 (此时减法等同于异或): 垫零原始数据 $div$ 串 得到余数
    - 原始数据后跟余数就是发送数据
  - 接收时
    - 接受到的数据 模二除 串, 余数必须为 $0$, 否则数据有误
- 流量控制: 滑动窗口
  - SW 协议: 发一个等一个确认
  - GBN 协议: $W_T <= 2^n - 1$, 一口气发 $W_T$ 个, 然后开始等确认, 确认一个就往后再发一个. 有一个确认收不到就重传所有正在等确认的.
  - SR 协议: $W_T <= 2^(n - 1)$, GBN, 但是接收方可以用 NACK 包指定要重传哪个
- 介质控制
  - 多设备复用: 码分复用: CDMA
    - 每个设备有一个向量. 链路上的数据序列和设备向量内积之后, 结果是正的就是这个设备在发 $1$, 负的就是在发 $0$, 零就是这个设备没有在发
  - 半双工线路防止争用: CSMA/CD
    - 先听后发, 边听边发, 冲突即停, 随机重发
    - 等待时间: $r = "rand"[0, 2^(min("重传次数", 10)) colored(- 1)]$, 等 $r$ 这么多倍争用期时间

== 传输层

- TCP 基础
  - TCP 的序号是数据的字节序号 (不算头长), 不是 MSS 序号
  - 三次握手: SYN, SYN+ACK, ACK
  - 四次挥手: FIN, ACK, FIN+ACK, ACK
  - 带 SYN 和 FIN 的包不准携带数据, 消耗一个序号; 带 ACK 的包可选地携带数据, 根据携带的数据大小消耗序号, 不携带则不消耗
- TCP 拥塞控制
  - cwnd 指同时发送多少个 MSS
  - 慢开始: cwnd = 1, 然后 1, 2, 4, 8, ..., 直到 ssthresh; 此后每次成功完整传送之后 cwnd += 1; 
  - 拥塞避免: 一旦拥塞, ssthresh = cwnd / 2, 然后
      - 慢恢复 (超时时用): cwnd = 1, 重复慢开始
      - 快恢复 (三冗余 ACK 时用): cwnd = ssthresh